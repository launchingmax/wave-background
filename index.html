<!doctype html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Half Section – Dense Dot Hills (No Repeat, Same Look)</title>
    <style>
        html,
        body {
            margin: 0;
            height: 100%;
            background: #FFFFFF;
            overflow: hidden;
        }

        #dotWave {
            position: fixed;
            left: 0;
            bottom: 0;
            width: 100vw;
            height: 50vh;
            pointer-events: none;
        }
    </style>
</head>

<body>
    <canvas id="dotWave"></canvas>
    <script>
        const canvas = document.getElementById("dotWave");
        const ctx = canvas.getContext("2d", { alpha: true });
        /* ===== Visual Settings ===== */
        const BG = "#FFFFFF";
        const DOT = "rgba(120,120,120,0.55)";
        const DOT_SIZE = 1.1;
        const GRID = 9.5;
        const SPEED = 0.55;
        /* ===== Hills ===== */
        const AMP_Y = 58;
        const AMP_X = 18;
        const LAYERING = 0.95;
        /* Base frequencies (your good look) */
        const W1_BASE = 0.014;
        const W2_BASE = 0.022;
        const W3_BASE = 0.009;
        /* Depth */
        const PERSPECTIVE = 0.25;
        /* Fades */
        const TOP_FADE_PX = 160;
        const EDGE_FADE_PX = 70;
        /* Right-to-left travel speed (px/sec in input domain) */
        const FLOW1 = 140;
        const FLOW3 = 90;
        /* :white_check_mark: Stronger but still subtle warp (keeps the same style) */
        const WARP_SCALE = 0.009;  // was 0.006
        const WARP_AMP_X = 30;     // was 18
        const WARP_AMP_Y = 18;     // was 12
        /* :white_check_mark: Extra anti-repeat (very subtle) */
        const PHASE_AMP = 0.75;    // tiny phase jitter (radians-ish)
        const FREQ_DRIFT = 0.06;   // +/-6% local frequency drift (very small)
        // Smooth value noise (continuous)
        function hash(n) {
            n = (n << 13) ^ n;
            return 1.0 - (((n * (n * n * 15731 + 789221) + 1376312589) & 0x7fffffff) / 1073741824.0);
        }
        function noise2(x, y) {
            const xi = Math.floor(x), yi = Math.floor(y);
            const xf = x - xi, yf = y - yi;
            const n00 = hash(xi + yi * 57);
            const n10 = hash((xi + 1) + yi * 57);
            const n01 = hash(xi + (yi + 1) * 57);
            const n11 = hash((xi + 1) + (yi + 1) * 57);
            const u = xf * xf * (3 - 2 * xf);
            const v = yf * yf * (3 - 2 * yf);
            const nx0 = n00 + (n10 - n00) * u;
            const nx1 = n01 + (n11 - n01) * u;
            return nx0 + (nx1 - nx0) * v; // ~[-1,1]
        }
        function smoothstep(e0, e1, x) {
            const t = Math.min(1, Math.max(0, (x - e0) / (e1 - e0)));
            return t * t * (3 - 2 * t);
        }
        /* ===== Resize ===== */
        function resize() {
            const dpr = Math.max(1, window.devicePixelRatio || 1);
            const cssW = window.innerWidth;
            const cssH = Math.round(window.innerHeight * 0.5);
            canvas.width = Math.floor(cssW * dpr);
            canvas.height = Math.floor(cssH * dpr);
            canvas.style.width = cssW + "px";
            canvas.style.height = cssH + "px";
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        }
        window.addEventListener("resize", resize);
        resize();
        /* ===== Animation ===== */
        let t0 = performance.now();
        function frame(now) {
            const t = ((now - t0) / 1000) * SPEED;
            const w = canvas.clientWidth;
            const h = canvas.clientHeight;
            ctx.fillStyle = BG;
            ctx.fillRect(0, 0, w, h);
            const pad = 70;
            const cols = Math.ceil((w + pad * 2) / GRID);
            const rows = Math.ceil((h + pad * 2) / GRID);
            ctx.fillStyle = DOT;
            for (let r = 0; r <= rows; r++) {
                const v = r / rows;
                const depth = 1 + v * LAYERING;
                const persp = 1 - PERSPECTIVE * (1 - v);
                const yBase0 = -pad + r * GRID * persp;
                // small per-row offset (breaks “same track” feeling)
                const rowJitter = noise2(r * 0.11, 2.7) * 0.55;
                for (let c = 0; c <= cols; c++) {
                    const xBase0 = -pad + c * GRID;
                    const warpT = t * 0.35;
                    // Warp inputs (domain warp)
                    const wx = noise2(xBase0 * WARP_SCALE + warpT, yBase0 * WARP_SCALE) * WARP_AMP_X;
                    const wy = noise2(xBase0 * WARP_SCALE, yBase0 * WARP_SCALE - warpT) * WARP_AMP_Y;
                    const xIn = xBase0 + wx;
                    const yIn = yBase0 + wy;
                    // :white_check_mark: Local frequency drift (tiny): breaks periodic repetition while keeping style
                    const drift = noise2(xIn * 0.0012, yIn * 0.0012 + warpT) * FREQ_DRIFT; // ~[-0.06, 0.06]
                    const W1 = W1_BASE * (1 + drift);
                    const W2 = W2_BASE * (1 - drift * 0.65);
                    const W3 = W3_BASE * (1 + drift * 0.8);
                    // :white_check_mark: Phase jitter (tiny): breaks “3 identical waves”
                    const phase = noise2(xIn * 0.0022 - warpT, yIn * 0.0022 + warpT) * PHASE_AMP;
                    // Right-to-left motion in x-domain (no vertical scrolling)
                    const n1 = Math.sin(((xIn - t * FLOW1) * W1) + r * 0.25 + rowJitter + phase);
                    const n2 = Math.sin((yIn * W2) + phase * 0.55);
                    const n3 = Math.sin((((xIn - t * FLOW3) + yIn) * W3) + phase * 0.75);
                    const dx = (n1 * 0.6 + n3 * 0.4) * AMP_X * depth;
                    const dy = (n2 * 0.55 + n3 * 0.45) * AMP_Y * depth;
                    const x = xBase0 + dx;
                    const y = yBase0 + dy;
                    const fadeLR = Math.min(
                        smoothstep(0, EDGE_FADE_PX, x + pad),
                        smoothstep(0, EDGE_FADE_PX, (w + pad) - x)
                    );
                    const fadeBottom = smoothstep(0, EDGE_FADE_PX, (h + pad) - y);
                    const fadeTop = smoothstep(0, TOP_FADE_PX, y);
                    const alpha = fadeLR * fadeBottom * fadeTop;
                    if (alpha < 0.002) continue;
                    ctx.globalAlpha = alpha * (0.35 + 0.35 * (0.5 + 0.5 * n3));
                    const size = DOT_SIZE * (0.85 + 0.25 * (0.5 + 0.5 * n2));
                    ctx.beginPath();
                    ctx.arc(x, y, size, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            ctx.globalAlpha = 1;
            requestAnimationFrame(frame);
        }
        requestAnimationFrame(frame);
    </script>
</body>

</html>